(require "unittest.ta")

(printTest "Test of scoping")
(printStep "Test of custom let")

(def [test-global1] 1)
(def [test-global2] 2)
(def [test-global3] 3)
(def [test-global4] 4)

(def [a] test-global1)
(def [b] test-global2)

(let [(= [a] test-global3) (= [b] test-global4)] [do (assert a test-global3 "new value inside let") (assert b test-global4 "new value inside let")])

(let [(= [a] test-global3)] [let [(= [b] test-global4)] 
[do (assert a test-global3 "new value inside let") (assert b test-global4 "new value inside let")]])

(let [(= [a] test-global3)] [let [(= [a] test-global4)] 
[do (assert a test-global4 "new value inside let")]])

(assert a test-global1 "Global not modified")
(assert b test-global2 "global not modified")

(printStepResult)

(printStep "Nested function declaration")
(def [testvar] 1)
(defun [test-set] [set [testvar] 2])
(test-set)
(assert testvar 2 "Modified by global method")

(defun [test-outer] [do (defun [test-set] [set [testvar] 5]) (test-set)])
(test-outer)

(assert testvar 5 "Modified by local method")
(test-set)
(assert testvar  2 "Modified by global method again")

(printStepResult)

(printStep "Return function as result")

(defun [create x] [lambda [a] [+ x a]])

(def [testcreate] (create 8))
(def [testcreate2] (create 10))

(assert (testcreate 1) 9 "create works")
(assert (testcreate2 1) 11 "create works")


(printStepResult)

(printStep "Correct reference to global scope")
(def [x] 10)
(defun [testglobal v] [+ x v])

(assert (let [(= x 20)] [testglobal 10]) 20 "correct scope referenced")

(printStepResult)

(printStep "Lexical scoping")

(def [test] (let [(= [a] 1)
		 (= [b] 2)
		 (= [f] (lambda [] [F]))
		 (= [g] (lambda [c] [G]))]
		 [lambda [d] [+ (f) (g b)]]))

(def [F] 10)
(def [G] 20)
(assert (test 4) 30 "Scoping example works")
(printStepResult)

(printTestResult)
